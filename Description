

// Maid is signed by Anmaid(selfsigned)
// Pmid is signed by Anpmid(selfsigned)
// Mpid is signed by Anmpid(selfsigned)

Instead of using this
// ========== Self-signed Fob ======================================================================
template <typename TagType>
class Fob<TagType, typename std::enable_if<is_self_signed<TagType>::type::value>::type> {
 public:
  using Signer = Fob<typename SignerFob<TagType>::Tag>;
  
  
We use a class named Fob_Self_Signed:

// ========== Self-signed Fob ======================================================================
template <typename TagType>
class Fob_Self_Signed{
 public:
  using Signer = Fob_Self_Signed<typename SignerFob<TagType>::Tag>;
  using Tag = TagType;
  using ValidationToken = asymm::Signature;

  // This constructor is only available to this specialisation (i.e. self-signed Fob).
  Fob_Self_Signed()
      : keys_(asymm::GenerateKeyPair()),
        validation_token_(CreateValidationToken()),
        name_(CreateName()) {
    static_assert(std::is_same<Fob_Self_Signed<Tag>, Signer>::value,
                  "This constructor is only applicable for self-signing Fob_Self_Signeds.");
  }

  Fob_Self_Signed(const Fob_Self_Signed& other)
      : keys_(other.keys_), validation_token_(other.validation_token_), name_(other.name_) {}

  Fob_Self_Signed(Fob_Self_Signed&& other)
      : keys_(std::move(other.keys_)),
        validation_token_(std::move(other.validation_token_)),
        name_(std::move(other.name_)) {}

  friend void swap(Fob_Self_Signed& lhs, Fob_Self_Signed& rhs) {
    using std::swap;
    swap(lhs.keys_, rhs.keys_);
    swap(lhs.validation_token_, rhs.validation_token_);
    swap(lhs.name_, rhs.name_);
  }

  Fob_Self_Signed& operator=(Fob_Self_Signed other) {
    swap(*this, other);
    return *this;
  }

  Fob_Self_Signed(const crypto::CipherText& encrypted_Fob_Self_Signed, const crypto::AES256KeyAndIV& symm_key_and_iv)
      : keys_(), validation_token_(), name_() {
    try {
      SerialisedData serialised_Fob_Self_Signed(crypto::SymmDecrypt(encrypted_Fob_Self_Signed, symm_key_and_iv).string());
      Parse(serialised_Fob_Self_Signed, keys_, validation_token_, name_);
    } catch (const std::exception&) {
      BOOST_THROW_EXCEPTION(MakeError(CommonErrors::parsing_error));
    }
    ValidateToken();
  }

  crypto::CipherText Encrypt(const crypto::AES256KeyAndIV& symm_key_and_iv) const {
    crypto::PlainText serialised_Fob_Self_Signed(Serialise(keys_, validation_token_, name_));
    return crypto::SymmEncrypt(serialised_Fob_Self_Signed, symm_key_and_iv);
  }

  Identity name() const { return name_; }
  ValidationToken validation_token() const { return validation_token_; }
  asymm::PrivateKey private_key() const { return keys_.private_key; }
  asymm::PublicKey public_key() const { return keys_.public_key; }

 private:
  Identity CreateName() const {
    return crypto::Hash<crypto::SHA512>(Serialise(keys_.public_key, validation_token_));
  }

  ValidationToken CreateValidationToken() const {
    return asymm::Sign(asymm::PlainText(Serialise(keys_.public_key, Tag::type_id)),
                       keys_.private_key);
  }

  void ValidateToken() const {
    // Check the validation token is valid
    if (!asymm::CheckSignature(asymm::PlainText(Serialise(keys_.public_key, Tag::type_id)),
                               validation_token_, keys_.public_key)) {
      BOOST_THROW_EXCEPTION(MakeError(CommonErrors::parsing_error));
    }
    // Check the private key hasn't been replaced
    asymm::PlainText plain(GetRandomString());
    if (asymm::Decrypt(asymm::Encrypt(plain, keys_.public_key), keys_.private_key) != plain)
      BOOST_THROW_EXCEPTION(MakeError(CommonErrors::parsing_error));
    // Check the name is the hash of the public key + validation token
    if (CreateName() != name_)
      BOOST_THROW_EXCEPTION(MakeError(CommonErrors::parsing_error));
  }

  asymm::Keys keys_;
  ValidationToken validation_token_;
  Identity name_;
}


